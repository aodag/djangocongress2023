#+TITLE: django migrationで学ぶデータベース設計
#+AUTHOR: Atsushi Odagiri
#+DATE: 2023-10-07
#+BEAMER_THEME: Madrid
#+BEAMER_COLOR_THEME: beetle
#+OPTIONS: H:2 toc:t num:t
#+OPTIONS: ^:{}
#+LaTeX_CLASS: beamer
#+LaTeX_HEADER: \usepackage{luatexja}
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)

* django migrationで学ぶデータベース設計

** はじめに
djangoにはmigrationというデータベーススキーマの変更を管理するツールがあります。
非常にありがたい存在のdjango migrationがやってくれることを今一度確認してみましょう。
データベース設計やオブジェクト指向設計などの面から安全で影響の少ないテーブル変更を考えてみましょう。
** COMMENT メモ
- django migration
  - 問題提起
  - django migrationの一般的な話
  - スキーマ操作のコスト
  - django appsをまたいだ場合の複雑さ
  - 大きなモデルの変更がいろんなdjango appに影響を与える
  - 小さく設計するしか？
- データベース設計から
  - 正規化
- オブジェクト指向から
  - ユースケースによる分離
  - ライフサイクル
- オブジェクト指向からデータベース設計に
  - ライフサイクル
    - ライフサイクルが異なるならアイデンティティは分離される
    - アイデンティティの分離 -> 推移関数従属
  
** お前誰よ

- aodag
- Atsushi ODAGiri
- 株式会社オープンコレクター
- python ... 1.5 くらい
- django ... 0.96とかsvnのリビジョンで安定してるやつとか

* django migration

** django migrationがやること

- データベーススキーマの変更管理
- モデルの差分からスキーマ変更スクリプトを作成する
- スキーマ変更スクリプトの世代を進めたり戻したりする

** スキーマの構成要素

- テーブル
- カラム
- インデックス
- 制約

** スキーマ変更の実行コスト

- メタデータの変更のみ
  - 制約の変更やインデックスの作成など
- データ更新
  - カラムの末尾への追加やカラム名変更など
- テーブル構造の再構築
  - カラムの削除

** スキーマ変更の下位互換性

- テーブルの追加
- カラムの追加
- 制約の緩和
- インデックスの有無

** スキーマ変更履歴の管理

- django appごとに世代管理
- django appsをまたぐ依存関係

** モデルは小さく設計しよう
- 小さいことはいいことだ
  - スキーマ変更時の実行コスト
  - スキーマ変更影響範囲

* データベース設計

** 正規化

- 正規化とは
- データを効率的に保存する
** 第一正規化
- 繰り返しの排除
- ~ARRAY~ とか使えるDBもありますが...

** 第二正規化
- 部分関数従属性の排除
- 候補キーの一部で確定可能なデータ

** 第三正規化
- 推移的関数従属性
- 候補キー以外の項目で確定可能なデータ

** テーブル

- エンティティ
  - 主に人が情報入力するデータ
- イベント
  - 主に機能が発生させるデータ
- サマリー
  - イベントをある時点で集約したものなど
- 補助
  - アプリケーションの内部制御などで使うようなもの

** エンティティ

- 現実世界の人モノコト金などの情報が多い
- それ以外にも分析や設計で概念を発見することもある

* オブジェクト指向

** ユースケース駆動の設計

- ユースケース: アクターが複数の機能を利用してなんらかの目的を達成する
- アクター: システム外のなにか(人とか時間とか別システムや現実世界のイベントとか)
- 機能: 入力を処理して出力を返すもの

** ドメインオブジェクト

- 明らかなもの
- ドメイン分析で発見できるもの
- リファクタリングで発見もの
- だいたいエンティティとしてDBに保存する

** オブジェクト指向設計原則(SOLID)

- 単一責任の原則
- 開放閉鎖の原則
- リスコフの置換原則
- インターフェース分離の原則
- 依存性逆転の原則

** 開放閉鎖の原則

- 他のユースケースに影響を与えない
- 該当ユースケースの機能変更だけで済ませる

** インターフェイス分離

- 必要のないモデルにアクセスしない

* オブジェクト指向からデータベース設計へ
** django appsとモデル設計に活かす

- モデルのライフサイクルに着目
- あるdjango appsで生成されるモデルに別のdjango appが情報を追加していく
  - ドメインオブジェクトの発見： その情報に名前をつけ、モデルなのでは？
  - インターフェイス分離： そのdjango appではそのモデルだけを処理対象にできるのでは？
  - 開放閉鎖の原則: 生成もとのdjango appに影響を与えずに新たなモデルのみを変更可能か？
    
** モデル分割の実際

Aアプリのモデル ~ModelA~ から, Bアプリの ~ModelB~ に一部分離する

- Bアプリ ~ModelB~ のテーブル追加
- Aアプリ ~ModelA~ のテーブルから該当フィールドに対応するカラムのデータを ~ModelB~ のテーブルにコピー
  - UPDATE JOIN とか UPDATE SELECT とかデータベースごとに違う！
  - あとこれAとBのどっちのmigrationsに入れるべき？
- Aアプリから該当カラム削除
  - ALTER TABLE a_amodel DROP COLUMN ...
  - テーブル再構築のコストがかかるやつ
  - しかも一度に複数カラムをDROPできない
- カラム削除があるのでカナリアやブルーグリーン不可能

** モデル分割

- 一時的にテーブルの一部分だけを他のテーブルに見せかけることができれば！
- データマッパーのORMだったらできたのに！

** 更新可能VIEW！

- djangoのviewじゃないよ
- RDBMSの機能
- ある条件で作成されたVIEWは更新も可能
  - クエリ対象が1テーブルのみ
  - 集約を含まない
  - SELECTに主キーを含む
  - SELECTに計算を含まない
  - ...

** とはいえ
- レイヤーの違う部分のハックは別の問題を持ち込みやすいので注意
- 問題解決にとてもコストがかかる...

* まとめ

** まとめ

- マイグレーションの中でもコストや下位互換性など特性が異なる操作がある
- データベース設計やオブジェクト指向設計などの知見を活かしましょう
  - 他にも活かせるものはたくさんあるはず
- 小さいことはいいことだ
- 原理原則やベストプラクティスに生きていけないから人は悩むのです

** 参考文献
- プログラマのためのSQL 第4版 すべてを知り尽くしたいあなたに, Joe Celko, ISBN ISBN-13978-4798128023
- ユースケース駆動開発実践ガイド, ダグ・ローゼンバーグ, ISBN 978-4798114453
- Let's POSTGRES! / PostgreSQL 9.3の新機能: 更新可能VIEW, https://lets.postgresql.jp/documents/technical/9.3/updatable_view/1
- MySQL 8.0 リファレンスマニュアル / 15.12.1 オンライン DDL 操作, https://dev.mysql.com/doc/refman/8.0/ja/innodb-online-ddl-operations.html

* COMMENT スキーママイグレーション
** スキーマの構成要素
- table
- column
- index
- constraints
  - null
  - foreign key
  - unique
** スキーマの操作
- alter table
- add column
- drop column
- rename
- modify column
- drop constraints
** django migrate
- makemigrations
- migrate
- sqlmigrate
- showmigrations
** sqlmigrate
** スキーマ変更のコスト(MySQLの例)
- 制約の追加
- カラムの(末尾への)追加
  - AFTERやFIRSTを伴うような末尾以外への追加はコストが大きい
- カラムの削除
  - テーブルが再構築されるのでコストが大きい
- インデックスの追加
- デフォルト値の変更
** 複数のdjango appにまたがってdowngradeする
- 人類に制御しきれるのか？
** 小さいことはいいことだ
- オブジェクト指向の最小インターフェイス
- テーブル物理設計 小さいテーブルはキャッシュされやすい
- ORMは全カラムをselectしがち 転送量が少ない
- マイグレーション 小さいテーブルの変更はコストが低い
** 小さくする
- 構造に着目 正規化
- ライフサイクルに着目 ユースケース
* COMMENT 論理設計
** 現実するもののデータ
- マスタ
- エンティティ
- 人モノコト金
** 発生するデータ
- イベント
- トランザクション
- 申込み決済
** 補助的なデータ
- サマリー
- 集計
* COMMENT 物理設計
** 正規化しろ
- 正規化はmigrationにも効く
** データベース設計と正規化
- なぜ正規化するか
- 正規化の目的
** 正規化の方法
- 第一正規化
- 第二正規化
- 第三正規化
** 第一正規化
- 繰り返しの排除
** 第二正規化
- 部分関数従属性
- だいたい親子関係のテーブルになる
- 主キーの共通部分があるので多くの場合はライフサイクルをともにする
- オブジェクト指向でいうと ~a-part-of~

#+begin_quote
主キーが複数あるテーブルにおいて、そのうちの一部のキーだけで決定できる項目がある場合が部分関数従属です。
#+end_quote

** 第三正規化
- 推移関数従属性
- 通常

#+begin_quote
推移関数従属性とは、テーブル内の一部の項目がキーでない項目によって決定されることです。
#+end_quote

** 残りを正規化

第四正規形・第五正規形編

** 正規化の効果
- データ空間効率
- 依存関係とスキーママイグレーション
  
** モデル設計と正規化

** 列挙型
- https://www.postgresql.jp/docs/9.2/datatype-enum.html
- https://dev.mysql.com/doc/refman/8.0/ja/enum.html
- あんまりよくない？
** django.db.models.TextChoices, IntegerChoices
- アプリケーションに依存
** 参照テーブル
- データがスキーマ定義に必要
- マイグレーションにデータ操作が入り込む
* COMMENT django appsとユースケース
** ユースケースとアクター
- 誰がシステムを使ってどんな目的を達成するか
** ユースケースと機能
- アクターは複数の機能を使って目的を達成する
** アクターとロール
- アクターはロール(グループ)の原型になる
- ロールに権限を割り当てる
** ユースケースをdjango appでまとめる
- 複数の機能をまとめる
- 機能
  - inputを処理してoutputを返す
  - djangoで言うならrequestを受け取ってresponseを返す(+モデルを変更して保存する)viewのこと
** モデルと機能
- モデルの置き場所
- 機能(views)の置き場所
** アクター、ユースケースの違いで分ける
- アクター、ユースケースの違い = ライフサイクルの違い
- 別の人が情報を追加する = 別のユースケース
- 正規化では見つけられないかも？
- ユースケースごとにdjango appを作る
** 行単位のライフサイクル
- INSERT,UPDATE,DELETE
** カラム単位のライフサイクル
- カラムがNULLじゃなくなるとき
- カラムがNULLになるとき
** UserCredentialとUserProfileを同じモデルにするな
- 認証時にプロフィールは必要ない
- プロフィールを参照するときにパスワードは必要ない
** データの管理
- データフィクスチャ
- migrationでデータ投入は是か非か
* COMMENT django ORMとオブジェクト指向
** オブジェクト指向との折り合い
- インターフェイス最小の原則
  - テーブルも小さく
  - SELECTを少なく
** だめだと思うところ
- DBをただのオブジェクト保管庫だと思ってそう
- そのわりにはクラス構造がテーブルにひっぱられる
- RDBMSの制限だけ受けていいところを使えない（使いにくい）
** もっとデータベースを知ってモデル設計しましょう
- テーブル設計
  - 正規化
- オブジェクト指向
  - ユースケース

